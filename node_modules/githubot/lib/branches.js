// Generated by CoffeeScript 1.9.1
(function() {
  var async,
    slice = [].slice;

  async = require("async");

  module.exports = function(repo, cb) {
    if (cb != null) {
      return this.get("repos/" + (this.qualified_repo(repo)) + "/branches", cb);
    } else {
      return {
        create: (function(_this) {
          return function(branchName, opts, cb) {
            var ref;
            if (cb == null) {
              ref = [{}, opts], opts = ref[0], cb = ref[1];
            }
            if (opts.from == null) {
              opts.from = "master";
            }
            return _this.get("repos/" + (_this.qualified_repo(repo)) + "/git/refs/heads/" + opts.from, function(json) {
              var sha;
              sha = json.object.sha;
              return _this.post("repos/" + (_this.qualified_repo(repo)) + "/git/refs", {
                ref: "refs/heads/" + branchName,
                sha: sha
              }, function(data) {
                return cb({
                  name: branchName,
                  commit: {
                    sha: data.object.sha,
                    url: data.object.url
                  }
                });
              });
            });
          };
        })(this),
        "delete": (function(_this) {
          return function() {
            var actions, branchName, branchNames, cb, fn, i, j, len;
            branchNames = 2 <= arguments.length ? slice.call(arguments, 0, i = arguments.length - 1) : (i = 0, []), cb = arguments[i++];
            actions = [];
            fn = function(branchName) {
              return actions.push(function(done) {
                return _this.request("DELETE", "repos/" + (_this.qualified_repo(repo)) + "/git/refs/heads/" + branchName, done);
              });
            };
            for (j = 0, len = branchNames.length; j < len; j++) {
              branchName = branchNames[j];
              fn(branchName);
            }
            return async.parallel(actions, cb);
          };
        })(this),
        merge: (function(_this) {
          return function(head, opts, cb) {
            var body, ref, ref1, ref2;
            if (cb == null) {
              ref = [{}, opts], opts = ref[0], cb = ref[1];
            }
            body = {
              base: (ref1 = (ref2 = opts.base) != null ? ref2 : opts.into) != null ? ref1 : "master",
              head: head
            };
            if (opts.message != null) {
              body.commit_message = opts.message;
            }
            return _this.post("repos/" + (_this.qualified_repo(repo)) + "/merges", body, function(data) {
              if (data == null) {
                return _this.logger.error("Nothing to merge");
              }
              return cb({
                sha: data.sha,
                message: data.commit.message,
                url: data.url
              });
            });
          };
        })(this)
      };
    }
  };

}).call(this);
