let readFile,Listr,pkgUp,uuid,GraphQLClient,checkForUpdates,checkPackageJson,getEnv,getOptions,createLogger,NonTTYRenderer,parseArgs,getTasks,fatalError,fetchError,runtimeError,taskError,intro;_34e‍.x([["main",()=>main],["runAll",()=>runAll],["runBuild",()=>runBuild]]);_34e‍.w("jsonfile",[["readFile",["readFile"],function(v){readFile=v}]]);_34e‍.w("listr",[["default",["Listr"],function(v){Listr=v}]]);_34e‍.w("pkg-up",[["default",["pkgUp"],function(v){pkgUp=v}]]);_34e‍.w("uuid",[["v4",["uuid"],function(v){uuid=v}]]);_34e‍.w("./io/GraphQLClient",[["default",["GraphQLClient"],function(v){GraphQLClient=v}]]);_34e‍.w("./lib/checkForUpdates",[["default",["checkForUpdates"],function(v){checkForUpdates=v}]]);_34e‍.w("./lib/checkPackageJson",[["default",["checkPackageJson"],function(v){checkPackageJson=v}]]);_34e‍.w("./lib/getEnv",[["default",["getEnv"],function(v){getEnv=v}]]);_34e‍.w("./lib/getOptions",[["default",["getOptions"],function(v){getOptions=v}]]);_34e‍.w("./lib/log",[["createLogger",["createLogger"],function(v){createLogger=v}]]);_34e‍.w("./lib/NonTTYRenderer",[["default",["NonTTYRenderer"],function(v){NonTTYRenderer=v}]]);_34e‍.w("./lib/parseArgs",[["default",["parseArgs"],function(v){parseArgs=v}]]);_34e‍.w("./tasks",[["default",["getTasks"],function(v){getTasks=v}]]);_34e‍.w("./ui/messages/errors/fatalError",[["default",["fatalError"],function(v){fatalError=v}]]);_34e‍.w("./ui/messages/errors/fetchError",[["default",["fetchError"],function(v){fetchError=v}]]);_34e‍.w("./ui/messages/errors/runtimeError",[["default",["runtimeError"],function(v){runtimeError=v}]]);_34e‍.w("./ui/messages/errors/taskError",[["default",["taskError"],function(v){taskError=v}]]);_34e‍.w("./ui/messages/info/intro",[["default",["intro"],function(v){intro=v}]]);



















       async function main(argv) {
  const sessionId = uuid();
  const env = getEnv();
  const log = createLogger(sessionId, env);
  const packagePath = await pkgUp(); // the user's own package.json
  const packageJson = await readFile(packagePath);

  // Warning: chromaui/action directly invokes runAll, so if new properties or arguments are added
  // here, they must also be added to the GitHub Action.
  const ctx = { env, log, sessionId, packageJson, packagePath, ...parseArgs(argv) };
  await runAll(ctx);

  log.info('');
  process.exit(ctx.exitCode);
}

       async function runAll(ctx) {
  // Run these in parallel; neither should ever reject
  await Promise.all([runBuild(ctx), checkForUpdates(ctx)]);

  if (!ctx.exitCode || ctx.exitCode === 1) {
    await checkPackageJson(ctx);
  }
}

       async function runBuild(ctx) {
  ctx.log.info('');
  ctx.log.info(intro(ctx));

  try {
    ctx.options = await getOptions(ctx);
  } catch (e) {
    ctx.log.info('');
    ctx.log.error(e.message);
    ctx.exitCode = 254;
    return;
  }

  try {
    ctx.client = new GraphQLClient({
      uri: `${ctx.env.CHROMATIC_INDEX_URL}/graphql`,
      headers: {
        'x-chromatic-session-id': ctx.sessionId,
        'x-chromatic-cli-version': ctx.pkg.version,
      },
      retries: 3,
      log: ctx.log,
    });

    try {
      ctx.log.info('');
      if (ctx.options.interactive) ctx.log.queue(); // queue up any log messages while Listr is running
      const options = ctx.options.interactive ? {} : { renderer: NonTTYRenderer, log: ctx.log };
      await new Listr(getTasks(ctx.options), options).run(ctx);
    } catch (err) {
      if (err.code === 'ECONNREFUSED' || err.name === 'StatusCodeError') {
        ctx.log.info('');
        ctx.log.error(fetchError(ctx, err));
        return;
      }
      try {
        // DOMException doesn't allow setting the message, so this might fail
        err.message = taskError(ctx, err);
      } catch (ex) {
        const error = new Error(taskError(ctx, err));
        error.stack = err.stack; // try to preserve the original stack
        throw error;
      }
      throw err;
    } finally {
      // Handle potential runtime errors from JSDOM
      const { runtimeErrors, runtimeWarnings } = ctx;
      if ((runtimeErrors && runtimeErrors.length) || (runtimeWarnings && runtimeWarnings.length)) {
        ctx.log.info('');
        ctx.log.error(runtimeError(ctx));
      }

      ctx.log.flush();
      if (ctx.stopApp) ctx.stopApp();
      if (ctx.closeTunnel) ctx.closeTunnel();
    }
  } catch (error) {
    const errors = [].concat(error); // GraphQLClient might throw an array of errors

    if (errors.length && !ctx.userError) {
      ctx.log.info('');
      ctx.log.error(fatalError(ctx, errors));
    }

    // Not sure what exit code to use but this can mean error.
    if (!ctx.exitCode) ctx.exitCode = 255;
  }
}
