let checkout,findMergeBase,getUpdateMessage,isClean,isUpToDate,installDependencies,createTask,transitionTo,mergeBaseNotFound,workspaceNotClean,workspaceNotUpToDate,checkoutMergeBase,initial,installingDependencies,lookupMergeBase,pending,success,runRestoreWorkspace;_34e‍.x([["runPrepareWorkspace",()=>runPrepareWorkspace],["default",()=>_34e‍.o]]);_34e‍.w("../git/git",[["checkout",["checkout"],function(v){checkout=v}],["findMergeBase",["findMergeBase"],function(v){findMergeBase=v}],["getUpdateMessage",["getUpdateMessage"],function(v){getUpdateMessage=v}],["isClean",["isClean"],function(v){isClean=v}],["isUpToDate",["isUpToDate"],function(v){isUpToDate=v}]]);_34e‍.w("../lib/installDependencies",[["default",["installDependencies"],function(v){installDependencies=v}]]);_34e‍.w("../lib/tasks",[["createTask",["createTask"],function(v){createTask=v}],["transitionTo",["transitionTo"],function(v){transitionTo=v}]]);_34e‍.w("../ui/messages/errors/mergeBaseNotFound",[["default",["mergeBaseNotFound"],function(v){mergeBaseNotFound=v}]]);_34e‍.w("../ui/messages/errors/workspaceNotClean",[["default",["workspaceNotClean"],function(v){workspaceNotClean=v}]]);_34e‍.w("../ui/messages/errors/workspaceNotUpToDate",[["default",["workspaceNotUpToDate"],function(v){workspaceNotUpToDate=v}]]);_34e‍.w("../ui/tasks/prepareWorkspace",[["checkoutMergeBase",["checkoutMergeBase"],function(v){checkoutMergeBase=v}],["initial",["initial"],function(v){initial=v}],["installingDependencies",["installingDependencies"],function(v){installingDependencies=v}],["lookupMergeBase",["lookupMergeBase"],function(v){lookupMergeBase=v}],["pending",["pending"],function(v){pending=v}],["success",["success"],function(v){success=v}]]);_34e‍.w("./restoreWorkspace",[["runRestoreWorkspace",["runRestoreWorkspace"],function(v){runRestoreWorkspace=v}]]);















       const runPrepareWorkspace = async (ctx, task) => {
  const { patchHeadRef, patchBaseRef } = ctx.options;

  // Make sure the git repo is in a clean state (no changes / untracked files).
  if (!(await isClean())) {
    ctx.exitCode = 101;
    ctx.userError = true;
    ctx.log.error(workspaceNotClean());
    throw new Error('Working directory is not clean');
  }

  // Make sure both the head and base branches are up-to-date with the remote.
  if (!(await isUpToDate(ctx))) {
    ctx.exitCode = 102;
    ctx.userError = true;
    ctx.log.error(workspaceNotUpToDate(await getUpdateMessage()));
    throw new Error('Workspace not up-to-date with remote');
  }

  transitionTo(lookupMergeBase)(ctx, task);

  // Get the merge base commit hash.
  ctx.mergeBase = await findMergeBase(patchHeadRef, patchBaseRef);
  if (!ctx.mergeBase) {
    ctx.exitCode = 103;
    ctx.userError = true;
    ctx.log.error(mergeBaseNotFound(ctx.options));
    throw new Error('Could not find a merge base');
  }

  transitionTo(checkoutMergeBase)(ctx, task);
  await checkout(ctx.mergeBase);

  try {
    transitionTo(installingDependencies)(ctx, task);
    await installDependencies(); // this might modify a lockfile
  } catch (err) {
    ctx.mergeBase = undefined;
    ctx.exitCode = 104;
    ctx.log.error(err);
    await runRestoreWorkspace(); // make sure we clean up even when something breaks
    throw new Error('Failed to install dependencies');
  }
};

_34e‍.d(createTask({
  title: initial.title,
  steps: [transitionTo(pending), runPrepareWorkspace, transitionTo(success, true)],
}));
